material {
    name : "SemanticsOverlay",
    shadingModel : unlit,
    blending : transparent,
    doubleSided : true,
    depthWrite : false,
    depthCulling : false,
    parameters : [
        { type : sampler2d, name : confidenceTexture },
        { type : mat3, name : uvTransform },
        { type : float, name : tintAlpha }
    ],
    requires : [
        uv0
    ]
}

fragment {
    vec3 hsvToRgb(vec3 hsv) {
        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
        vec3 p = abs(fract(hsv.xxx + K.xyz) * 6.0 - K.www);
        return hsv.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), hsv.y);
    }

    void material(inout MaterialInputs material) {
        prepareMaterial(material);

        // Get base UV coordinates
        vec2 baseUV = getUV0();
        vec3 uvh = vec3(baseUV.x, baseUV.y, 1.0);
        vec3 transformedUvh = uvh * materialParams.uvTransform;

        // Convert back from homogeneous coordinates (perspective divide)
        vec2 uv = transformedUvh.xy / transformedUvh.z;

        float confidence = texture(materialParams_confidenceTexture, uv).r;
        float hue = mix(0.70, -0.15, clamp(confidence, 0.0, 1.0));
        if (hue < 0.0) {
            hue += 1.0;
        }

        vec3 hsv = vec3(hue, 0.9, 0.6);
        vec3 color = hsvToRgb(hsv);
        float alpha = clamp(materialParams.tintAlpha, 0.0, 1.0);
        material.baseColor = vec4(color, alpha);
    }
}
